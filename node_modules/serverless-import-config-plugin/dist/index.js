"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const fs_1 = require("fs");
const lodash_set_1 = __importDefault(require("lodash.set"));
const lodash_difference_1 = __importDefault(require("lodash.difference"));
const merge_1 = __importDefault(require("./merge"));
const utils_1 = require("./utils");
const SERVERLESS = 'serverless';
const DIRNAME = 'dirname';
const JS_EXTNAME = '.js';
const CONFIG_EXTNAMES = new Set(['.yml', '.yaml', JS_EXTNAME]);
const REALPATH = fs_1.realpathSync('.');
class ImportConfigPlugin {
    constructor(serverless) {
        var _a, _b;
        this.serverless = serverless;
        this.originalPlugins = (_b = (_a = this.serverless.service.plugins) === null || _a === void 0 ? void 0 : _a.slice(), (_b !== null && _b !== void 0 ? _b : []));
        this.importConfigs(this.serverless.service, { basedir: REALPATH });
        this.loadImportedPlugins();
    }
    getImports(config) {
        const { import: imports } = config.custom || {};
        if (Array.isArray(imports))
            return imports;
        if (typeof imports === 'string' && imports)
            return [imports];
        return [];
    }
    importConfigs(config, { basedir }) {
        this.getImports(config).forEach(pathToImport => this.importConfig(pathToImport, { basedir }));
    }
    resolvePathToImport(pathToImport, { basedir }) {
        var _a;
        // pass if has config extension
        if (CONFIG_EXTNAMES.has(path.extname(pathToImport))) {
            if (utils_1.tryOrUndefined(() => fs_1.statSync(pathToImport))) {
                return pathToImport;
            }
            const resolved = utils_1.tryOrUndefined(() => utils_1.resolveModule(pathToImport, { basedir }));
            if (resolved) {
                return resolved;
            }
            throw new this.serverless.classes.Error(`Cannot import ${pathToImport}: the given file doesn't exist`);
        }
        // if directory look for config file
        const stats = utils_1.tryOrUndefined(() => fs_1.statSync(pathToImport));
        if ((_a = stats) === null || _a === void 0 ? void 0 : _a.isDirectory()) {
            const tries = [];
            for (const configExtname of CONFIG_EXTNAMES) {
                const possibleFile = path.join(pathToImport, SERVERLESS + configExtname);
                if (utils_1.tryOrUndefined(() => fs_1.statSync(possibleFile))) {
                    return possibleFile;
                }
                tries.push(possibleFile);
            }
            throw new this.serverless.classes.Error(`Cannot import ${pathToImport}: `
                + 'in the given directory no serverless config can be found\n'
                + `Tried: \n - ${tries.join('\n - ')}`);
        }
        // try to resolve as a module
        const tries = [];
        for (const configExtname of CONFIG_EXTNAMES) {
            const possibleFile = path.join(pathToImport, SERVERLESS + configExtname);
            const resolved = utils_1.tryOrUndefined(() => utils_1.resolveModule(possibleFile, { basedir }));
            if (resolved) {
                return resolved;
            }
            tries.push(possibleFile);
        }
        throw new this.serverless.classes.Error(`Cannot import ${pathToImport}: `
            + 'the given module cannot be resolved\n'
            + `Tried: \n - ${tries.join('\n - ')}`);
    }
    prepareImportedConfig(options) {
        const { variables } = this.serverless;
        const { importPath, config } = options;
        // make all function handlers relative to the imported config file
        const { functions } = config;
        const importDir = path.relative(REALPATH, path.dirname(importPath));
        const toPosixPath = (location) => location.split(path.sep).join(path.posix.sep);
        if (functions != null) {
            Object.values(functions).forEach(func => {
                if (typeof func.handler === 'string') {
                    func.handler = toPosixPath(path.join(importDir, func.handler));
                }
            });
        }
        // replace all ${dirname} by the imported config file dirname
        variables.loadVariableSyntax();
        const properties = variables.getProperties(config, true, config);
        properties
            .filter(({ value }) => typeof value === 'string' && value.match(variables.variableSyntax))
            .map(property => ({ property, matches: variables.getMatches(property.value) }))
            .filter(({ matches }) => Array.isArray(matches))
            .forEach(({ property, matches }) => {
            matches
                .filter(({ variable }) => variable === DIRNAME)
                .forEach(({ match }) => {
                const newValue = property.value.replace(match, importDir);
                lodash_set_1.default(config, property.path, newValue);
            });
        });
    }
    importConfig(options, { basedir }) {
        var _a;
        const isFullOptions = typeof options === 'object' && options != null;
        const realOptions = isFullOptions ? options : { module: options, inputs: {} };
        const { module: pathToImport, inputs } = realOptions;
        this.serverless.cli.log(`Importing ${pathToImport}`);
        const importPath = this.resolvePathToImport(pathToImport, { basedir });
        let config;
        try {
            if (path.extname(importPath) === JS_EXTNAME) {
                const importExports = require(importPath);
                const importFunction = typeof importExports === 'function'
                    ? importExports
                    : (_a = importExports) === null || _a === void 0 ? void 0 : _a.default;
                config = importFunction(inputs);
            }
            else {
                config = this.serverless.utils.readFileSync(importPath);
            }
            this.prepareImportedConfig({ importPath, config });
            this.importConfigs(config, { basedir: path.dirname(importPath) });
        }
        catch (error) {
            throw new this.serverless.classes.Error(`Error: Cannot import ${pathToImport}\nCause: ${error.message}`);
        }
        merge_1.default(this.serverless.service, config);
    }
    loadImportedPlugins() {
        const { pluginManager } = this.serverless;
        const newPlugins = lodash_difference_1.default(this.serverless.service.plugins, this.originalPlugins);
        if (typeof pluginManager.loadServicePlugins === 'function') {
            pluginManager.loadServicePlugins(newPlugins);
        }
        else {
            pluginManager.resolveServicePlugins(newPlugins)
                .filter(Boolean)
                .forEach(plugin => pluginManager.addPlugin(plugin));
        }
    }
}
module.exports = ImportConfigPlugin;
//# sourceMappingURL=index.js.map